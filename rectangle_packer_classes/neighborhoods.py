import random
import copy
import numpy as np

from base_classes.types import  OptimizationProblem, Solution, Neighborhood
from rectangle_packer_classes.problem_classes import RecPac_Solution, Box
import rectangle_packer_classes

class GeometryBasedStrategy(Neighborhood):
    """
    Geometry-based neighborhood strategy for generating neighboring solutions in the rectangle packing problem by moving rectangles inside and between boxes.

    Attributes:
        problem (OptimizationProblem): optimization problem instance
        solution_type (type): Type of the solution used in the problem
    """
    def __init__(self, problem: OptimizationProblem, solution_type: type):
        self.problem = problem
        self.solution_type = solution_type

    def generate_neighbor(self, solution: Solution):
        """Generates a neighboring solution by moving rectangles inside a box or from one box to another.

        Args:
            solution (Solution): current solution for which a neighbor will be generated

        Returns:
            Solution: new solution state after moving rectangles 
        """
        # return same solution, if there are no boxes present
        if not solution.boxes:
            return solution
        
        # deep copy the solution to create a neighbor
        new_solution = copy.deepcopy(solution)

        # choose last box to attempt moving an item from there
        box_from = new_solution.boxes[-1]
        if not box_from.items:
            new_solution.check_if_box_empty(box_from)
            return new_solution

        # attempt to move each item from chosen box
        for _ in range(len(box_from.items)):
            rect_to_move = random.choice(box_from.items)
            box_from.remove_item(rect_to_move)

            index = 0

            # try placing the item in other boxes [assumption: atleast one box can fit the rectangle]
            while True:
                if index >= len(new_solution.boxes):
                    break
                
                box_to = new_solution.boxes[index]

                # find valid position for rectangle in the current box
                x, y, rotated = self.problem.find_valid_assignment(box_to, rect_to_move)

                # if a valid position is found, place the rectangle 
                if x is not None and y is not None:
                    rect_to_move.x = x
                    rect_to_move.y = y
                    if rotated:
                        # if needed apply rotation
                        rect_to_move.width, rect_to_move.height = rect_to_move.height, rect_to_move.width
                    box_to.add_item(rect_to_move)
                    # remove the original box if it's empty after moving the item
                    new_solution.check_if_box_empty(box_from)
                    break
                
                else:
                    # move to the next box if no valid position is found
                    index += 1

        return new_solution


class RuleBasedStrategy(Neighborhood):
    """Rule-based neighborhood strategy for generating neighboring solutions in teh rectangle packing problem by rearranging rectangles according to a rule.

    Attributes:
        problem (OptimizationProblem): the optimization problem instance
        rule (str): rule name used to reorder rectangles
    """
    def __init__(self, problem: OptimizationProblem, rule: str):
        problem.items = rectangle_packer_classes.helpers.apply_rule(problem.items, rule)
        self.problem = problem

    def generate_neighbor(self, solution: Solution):
        """Generates a neighboring solution by reordering rectangles based on a rule and swapping two adjacent rectangles

        Args:
            solution (Solution): current solution, for which a neighbor will be generated

        Returns:
            RecPac_Solution: a solution which is generated by changing the permutation of the given solutions rectangles 
        """
        # return if there are no boxes in current solution
        if not solution.boxes:
            return solution

        # create a new solution and collect all items from current boxes
        current_solution = RecPac_Solution()
        items = [] # current permutation
        for box in solution.boxes:
            items.extend(box.items)

        # only rearrange items if there are at least two rectangles
        if len(items) > 1:
            # reorder items based on the specified rule
            #items = rectangle_packer_classes.helpers.apply_rule(items, self.rule)

            # select a random rectangle from the smaller half of the rectangle lsit
            small_rectangles = items[:len(items) // 2]
            selected = random.choice(small_rectangles)

            # swap the selected recrtangle with its adjacent item
            i = items.index(selected)
            j = i + 1 if i < len(items) - 1 else i - 1 # adjacent index
            items[i], items[j] = items[j], items[i]

        # reset position and rebuild the solution
        for item in items:
            item.x, item.y = None, None # reset position

            # attempt to place the item into the solution
            new_solution = self.problem.add_to_solution(current_solution, item)

            # update the current solution if placement was successful
            if new_solution is not None:
                current_solution = new_solution

        return current_solution

class OverlapStrategy(Neighborhood):
    """Overlap-based neighborhood strategy for generating neighboring solutions in the rectnalge packing problem by gradually reducing overlap.

    Attributes:
        problem (OptimizationProblem): optimization problem instance
        initial_overlap (float): starting allowed overlap percentage
        decay (float): rate at which overlap is reduced per iteartion
    """
    def __init__(self, problem: OptimizationProblem, initial_overlap: float = 1.0, decay_rate: float = 0.05):
        self.overlap_percentage = initial_overlap
        self.decay_rate = decay_rate
        self.problem = problem

    def generate_neighbor(self, solution: Solution):
        """generates a neighboring solution by reducing the overlap of rectangles, based on teh current overlap percentage

        Args:
            solution (Solution): current solution, for which a neighbor will be generated

        Returns:
            Solution: a new solution which is a neighbor of previous one
        """
        # Note: deep copying avoided for performance reasons
        new_solution = solution

        # iterate through each box to check and resolve overlaps
        for box in new_solution.boxes:
            spatial_data = self.build_spatial_array(box)
            items_to_relocate = self.find_violating_rectangles(box, spatial_data)

            # remove and reassign overlapping rectangles
            for item in items_to_relocate:
                box.remove_item(item)
            self.reassign_rectangles(new_solution, items_to_relocate)

        # reduce allowed overlap percentage
        self.overlap_percentage = max(0.0, round(self.overlap_percentage - self.decay_rate, 6))
        
        # remove empty boxes from solution
        for box in new_solution.boxes:
            new_solution.check_if_box_empty(box)
            
        return new_solution

    def build_spatial_array(self, box: Box):
        """builds a spatial array containing coordinates and areas of rectangles in the box

        Args:
            box (Box): box containing the rectnalges

        Returns:
            np.array: array of spatial data for all rectangles in the box
        """
        if not box.items:
            return np.empty((0, 5), dtype=np.float32)

        # create array for vectorized overlap calculations
        return np.array([[rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, rect.width * rect.height] for rect in box.items], dtype=np.float32)

    def find_violating_rectangles(self, box, spatial_data):
        """identifies rectangles that violate the allowed overlap percentage

        Args:
            box (Box): box containing the rectangles which will be checked
            spatial_data (np.array): spatial data for overlap calculations

        Returns:
            list[rectangles]: list of rectangles that violate the overlap constraints
        """
        violating_items = []

        # check each rectangle for overlap violations
        for rect in box.items:
            rect_arr = np.array([rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, rect.width * rect.height], dtype=np.float32)
            if not self.check_overlap_vectorized(spatial_data, rect_arr, self.overlap_percentage):
                violating_items.append(rect)

        return violating_items

    def reassign_rectangles(self, new_solution, items_to_relocate):
        """attempts to reassign rectangles that violated the overlap constraints into existing or new boxes.

        Args:
            new_solution (Solution): current solution
            items_to_relocate (list[Rectangle]): list of items that will be reassigned
        """
        for item in items_to_relocate:
            placed = False
            
            # try to place item in current boxes
            for box in new_solution.boxes:
                x, y, rotated = self.problem.find_valid_assignment(box, item, self.overlap_percentage * 0.3)
                if x is not None:
                    item.x, item.y = x, y
                    if rotated:
                        item.width, item.height = item.height, item.width
                    box.add_item(item)
                    placed = True
                    break

            # if no valid position is found, create a new box
            if not placed:
                new_box = Box(new_solution.boxes[0].box_length)
                item.x, item.y = 0, 0
                new_box.add_item(item)
                new_solution.add_box(new_box)

    def check_overlap_vectorized(self, spatial_data, rect_arr, overlap_percentage):
        """CHecks if a rectangle exceeds the allowed overlap percentage with others.

        Args:
            spatial_data (np.array): spatial data for existing rectangles
            rect_arr (np.array): spatial data for the rectangle being checked
            overlap_percentage (float): maximum allowed overlap percentage

        Returns:
            bool: true if overlap is within the constraint, faklse otherwise
        """
        if spatial_data.shape[0] == 0:
            return True # no other rectangles, no overlap

        rect_x1, rect_y1, rect_x2, rect_y2, rect_area = rect_arr

        # claculate overlap using vectorized operations
        x_overlap = np.maximum(0, np.minimum(spatial_data[:, 2], rect_x2) - np.maximum(spatial_data[:, 0], rect_x1))
        y_overlap = np.maximum(0, np.minimum(spatial_data[:, 3], rect_y2) - np.maximum(spatial_data[:, 1], rect_y1))

        overlap_areas = x_overlap * y_overlap
        max_areas = np.maximum(rect_area, spatial_data[:, 4])

        # calculate overlap rations and check against the allowed percentage
        overlap_ratios = overlap_areas / max_areas
        if np.any(overlap_ratios > overlap_percentage):
            return False

        return True

